<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Blog Title</title><link>https://OnHaiping.github.io/blogs</link><description>Blog description</description><copyright>Blog Title</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://OnHaiping.github.io/blogs</link></image><lastBuildDate>Sun, 14 Jul 2024 09:06:59 +0000</lastBuildDate><managingEditor>Blog Title</managingEditor><ttl>60</ttl><webMaster>Blog Title</webMaster><item><title>FastAPI学习</title><link>https://OnHaiping.github.io/blogs/post/FastAPI-xue-xi.html</link><description>## FastAPI介绍&#13;
FastAPI两部分组成：&#13;
&#13;
&gt;starlette负责web部分(Asyncio)&#13;
&gt;&#13;
&gt;​	包含ASGI框架，能够实现构建异步服务器&#13;
&gt;&#13;
&gt;Pydantic负责数据部分(类型提示)如下面代码所示:&#13;
&gt;&#13;
&gt;```python&#13;
&gt;from datetime import datetime&#13;
&gt;from typing import Tuple&#13;
&gt;&#13;
&gt;from pydantic import BaseModel&#13;
&gt;&#13;
&gt;&#13;
&gt;class Delivery(BaseModel):&#13;
&gt;    timestamp: datetime&#13;
&gt;    dimensions: Tuple[int, int]&#13;
&gt;&#13;
&gt;&#13;
&gt;m = Delivery(timestamp='2020-01-02T03:04:05Z', dimensions=['10', '20'])&#13;
&gt;print(repr(m.timestamp))&#13;
&gt;# &gt; datetime.datetime(2020, 1, 2, 3, 4, 5, tzinfo=TzInfo(UTC))&#13;
&gt;print(m.dimensions)&#13;
&gt;# &gt; (10, 20)&#13;
&gt;```&#13;
&gt;&#13;
&gt;可以更好的处理数据&#13;
## HTTP协议的结构详解&#13;
&#13;
![image-20240322173443809](https://s2.loli.net/2024/03/22/fqPBxiajpsIAwTd.png)&#13;
&#13;
并且使用的http协议发送Get和Post请求的时候，需要设置好数据格式&#13;
&#13;
```python&#13;
# web应用程序  : 遵循http协议&#13;
import socket&#13;
&#13;
sock = socket.socket()&#13;
&#13;
sock.bind(('127.0.0.1', 1010))&#13;
sock.listen(5)&#13;
&#13;
while 1:&#13;
    # 服务端要实现先收再发&#13;
    conn, addr = sock.accept()  # 阻塞等待客户端连接&#13;
    data = conn.recv(1024)&#13;
    print('客户端发送的请求信息\n', data)&#13;
    # 请求的时候不用管是因为浏览器已经帮我们已经封装好了&#13;
&#13;
    # 如果是这样的话，不符合http协议，服务端没有按照http协议的格式来发送数据给客户端&#13;
    # conn.send(b'hello,world!')&#13;
&#13;
    # 换成下面这样的带有响应头的数据，就符合http协议了&#13;
    conn.send(b'HTTP/1.1 200 OK\r\nhi\r\n\r\n&lt;h1&gt;hello,world!&lt;/h1&gt;')&#13;
    conn.close()&#13;
   &#13;
```&#13;
&#13;
一般会给直接设置好&#13;
&#13;
##  API接口&#13;
&#13;
分离代表的是 职责 分离&#13;
&#13;
### 前后端分离&#13;
&#13;
![image-20240322174043560](https://s2.loli.net/2024/03/22/8BiyszQ3eOktEph.png)&#13;
&#13;
### 前后端不分离(主流)&#13;
&#13;
![image-20240322174255437](https://s2.loli.net/2024/03/22/ghLRcox46yp9WO8.png)&#13;
&#13;
## RESTful开发规范&#13;
&#13;
RESTful是一种专门为了Web开发而定义的API接口的设计风格，尤其适用于前后端分离的模式中。</description><guid isPermaLink="true">https://OnHaiping.github.io/blogs/post/FastAPI-xue-xi.html</guid><pubDate>Sun, 14 Jul 2024 08:35:25 +0000</pubDate></item></channel></rss>